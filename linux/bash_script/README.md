
<!-- https://inpa.tistory.com/entry/LINUX-%EC%89%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%95%B5%EC%8B%AC-%EB%AC%B8%EB%B2%95-%EC%B4%9D%EC%A0%95%EB%A6%AC -->
# Shell Script
## Shell Script란?
- Shell이나 command line 인터프리터에서 구동되도록 작성된 스크립트
- 인터프리터 방식: 
- hello.sh와 같이 `*.sh` 확장자를 갖는 파일이다

## 특수 문자
<!--https://jdm.kr/blog/4-->

| 종류 | 설명 |
| :---: | --- |
| {} | 안의 각 문자열과 일치 |
| [] | - 안의 문자열 중 하나와 일치<br> - [1-5]는 1부터 5(1, 2, 3, 4, 5)의미 -> 영역을 나타낼 수 있다 |
| [!] 또는 [^] | []의 여집합 |
| - | 양 옆 문자에서 문자 범위 설정 |
| * | 0개 이상의 문자 대체 |
| ? | 1개의 문자 대체 |
| ~ | 유저의 홈 디렉토리<br> (/home/<userid>) |
| . | 현재 디렉토리 |
| .. | 상위 디렉토리 |
| # | 주석 |
| \ | 특수문자 바로 앞에 사용되며, 특수문자의 효과를 없앤다 |
| > | redirection-출력의 방향을 바꾼다 <br> - 기호 뒤에 파일명이 온다면, 파일로 명령의 결과를 저장 <br> - 이때 존재하는 파일이라면 파일을 덮어쓴다 <br> - 존재하지 않는 파일이라면 파일을 생성하고 입력 |
| >> | redirection-출력의 방향을 바꾼다<br> - 기호 뒤에 파일명이 온다면, 파일로 명령의 결과를 저장<br> - 이때 존재하는 파일이라면 파일의 마지막 줄 이후로 내용 추가<br> - 존재하지 않는 파일이라면 파일을 생성하고 입력 |
| < | redirection-표준 입력의 방향을 바꾼다 <br>- 기호 뒤에 파일명이 오면 그 파일의 내용을 표준 입력으로 받아들임 |
| & | 백그라운드 작업 |
| ; | - 쉘 명령 구분자 <br> - 연결된 명령을 왼쪽부터 차례로 실행 |
| \| | - 파이프 <br> - 파이프 왼쪽의 실행 결과를 오른쪽 명령의 입력으로 전달<br> - **|$**와 같이 `&`과 함께 사용되면, **표준 에러** 도 함께 전달한다|
| ` | -  문자열 사이에 `로 감싼 문자열이 있다면 그것은 **명령어**로 해석된다<br> - 명령어의 결과가 출력된다 |
| '또는 " | - 문자를 감싸서 문자열로 만든다<br> - 작은 따옴표는 모든 특수 기호를 일반 문자로 간주하여 처리<br> - 큰 따옴표는 <kbd>$, `, \</kbd>를 제외한 모든 특수 기호를 일반 문자로 간주 |
| 0 | file descriptor- stdin(표준 입력) |
| 1 | file descriptor- stdout(표준 출력) |
| 2 | file descriptor- stderr(에러 출력) |


```console
$ ls test*
#이름이 test로 시작하는 모든 파일/디렉토리 출력

$ ls -al [!a-C]*
#파일명이 **a부터 C** 까지의 중 하나의 알파벳으로 시작하지 **않는** 모든 파일 출력

$ cat hello.txt | more
#cat hello.txt 명령의 결과를 more로 전달
#-> hello.txt의 내용을 **화면 단위로** 출력

$ echo '$SHELL' 
#화면에 $SHELL 이라는 문자열이 출력

$ echo "$SHELL"
#화면에 쉘 환경 변수인 SHELL의 값(현재 휄의 종류)이 출력된다

$ echo "Today is `date`"
#date가 `(백 쿼터)로 감싸 있으므로 명령어로 인식된다
```
```console
$ ./test.sh >> /dev/null 2>&1 
#표준 출력이 필요 없다(2는 에러, 1은 표준 출력) 
# 2>&1: 표준 에러 출력을 표준출력장치로 저장된 /dev/null로 리다이렉트한다
#/dev/null은 항상 비어있는 파일
```
- **2>&1** 동작 이해: <br>
  - 명령어가 실패하면 err내용이 저장, 명령어가 성공하면 성공한 표준 출력 결과가 저장되도록 한 명령어를 함축한 것 <br>
  - 표준 에러를 표준 출력(&1)으로 지정한다<br>
  - 표준 출력을 > 명령을 통해 파일로 재지정했다면 이 파일에 표준 에러가 담긴다 <br>

- **/dev/null** 이해: <br>
  - 화면에 표시하지 않겠다는 의미(이곳으로 전송된 데이터는 버려진다) <br>
<br>


 
## 환경 설정
### 1. 환경 변수 / 위치 매개변수 설정
 
- **echo $환경변수** 를 통해 환경 변수 값 확인 가능
- 환경 변수는 세션에만 유효하다(로그아웃 또는 재부팅 시 사라진다)
- 환경 변수를 영구적으로 적용하기 위해서는 설정 파일(**/etc/bash.bashrc**)에 설정한다
 -**/etc/bash.bashrc** 파일은 사용자가 로컬 터미널 세션을 열 때마다 실행하는 파일
- 특정 사용자에게만 환경변수를 영구적으로 적용하고 싶다면 **~/.bashrc**파일 수정
 - **set** 을 통해 **위치 매개변수** 설정 가능
 
 <br>
 
 ---
 
 #### 주요 환경 변수 (**export** 명령어를 통해 전체 확인 가능)
 
| 종류 | 설명 |
| :---: | --- |
| HOME | 사용자 홈 디렉토리 |
| PATH | 실행 파일을 찾을 경로 |
| LANG | 프로그램 사용 시 기본으로 지원되는 언어 |
| PWD | 사용자의 현재 작업중인 디렉토리 |
| SHELL | 로그인하여 사용하는 쉘 |
| BASH | Bash 실행 파일 경로 |
| PPID | 부모 프로세스의 PID |
| UID | 사용자 UID |
| USER | 사용자 이름 |
| GROUPS | 사용자 그룹 출력(`/etc/passwd`값 출력) |
| LANG | 프로그램 사용 시 기본으로 지원되는 언어 |
| EDITOR | 기본 편집기 이름 |

```console
 $ export
 #환경 변수 목록 확인
 
 $ echo $HOME 
 #home디렉토리의 경로 표시
```
<br> 
 
 ---
 
#### 위치 매개변수
 - 스크립트 이름 다음에 공백 문자로 구분된 각 단어
 
| 종류 | 설명 |
| :---: | --- |
| $0 | 쉘 스크립트 이름 |
| $1 부터 $10 | - 1부터 10 번째 매개변수<br> - 10번째부터는 ${10}과 같이 감싸준다 |
| $# | 위치 매개변수의 총 개수 |
| $* | 전체 인자 값 |
| $@ | 전체 인자값|
| "$*" | "$1 $2 $3" 꼴로 평가 |
| "$@" | "$1""$2""$3" 꼴로 평가 |
| $^ | 모든 위치 매개변수 평가 ???? |

 ```console
 $ ./test a b
 #다음과 같이 실행과 같이 넘겨주는 argument(a, b)를 위치 매개변수로 인식
 #$1에는 a가, $2에는 b가 저장
 #실행하는 파일인 test에서 이 값을 사용할 수 있다 
```
<br>

 ---
 
#### 기본 환경변수/위치 매개변수 설정
 
| 명령어 | 설명 |
| :---: | --- |
| env | **전역 변수** 설정, 조회 |
| set | - **사용자 환경 변수** 설정, 조회<br>- **쉘 환경 설정** |
| unset | **사용자 환경 변수** 해제 |
| export 환경변수명=환경변수값 | 사용자 환경 변수를 전역 변수로 설정 |
| export | 전체 환경 변수  |

```console
$ export JAVA_HOME=/usr/hava/jdk1.6.0
#JAVA_HOME 환경변수에 jdk경로를 등록한다

$ env | grep 환경변수
#환경변수 확인

$ unset 환경변수
#환경변수 해제
```
 
```console
$ vi /etc/bash.bashrc 
#vi 에디터를 이용해 /etc/bash.bashrc파일 접근
 
$ export JAVA_HOME=/usr/hava/jdk1.6.0
#파일의 맨 마지막 라인에 환경 변수 등록
```

<br>
 
 ---
 
#### set 명령어 주요 옵션
- **set --help** 명령어를 통해 전체 옵션 확인 가능
 
| 옵션 | 설명 |
| :---: | --- |
| -a | 값이 할당된 변수 export |
| **-e** | **오류** 가 발생하면 스크립트 종료 |
| -x | 수행하는 명령어 출력 후 실행 |
| -m | 작업이 완료되면 메시지 효시 |
| -o | 옵션 설정 |
| +옵션 | 옵션 끄기 |
 
```console
 $ cat a.sh #a.sh파일을 실행한다(cat을 통해 파일을 실행할 수 있다. 자세한 내용은 아래에*****)
 
 
```
 
 <!--
 > set 명령어 매개변수
- set /p variable=promptString
 
| 매개변수 | 설명 |
| :---: | --- |
| /p | 사용자가 입력한 입력 줄을 variable로 설정| 
-->
 

 
### 2. 계정 변경
###




## 문법
### 1. 첫 번째 행 작성 규칙 - Shebang
```console
#! /usr/bin/bash
```
- 첫번째 줄에 작성한 내용은 쉘 스크립트가 실행될 때 어떤 쉘로 스크립트를 실행할지 정의한다
- 여러 가지 쉘 중에서 bash로 실행하겠다는 선언을 첫줄에 작성한다.
- 이러한 쉘 선언문을 **Shebang** 이라고 한다.

```console
vi script.sh # vi편집기를 이용해 script 작성
$ bash script.sh #bash로 실행하면 권한을 주지 않고도 실행 가능 ????
```
```console
#쉘 스크립트 작성
#! /bin/bash
echo "Hello World!"
exit 0
 
#스크립트 실행
$ cat test.sh
```


 

### 2. 쉘 변수 선언
- 로컬 변수, 전역 변수, 환경 변수, 예약 변수, 매개 변수 등 존재
- 대, 소문자 구별



<! --
 스크립트 실행 방식
1. sh 실행할파일
2. bash 실행할파일
3. ./실행할파일
 
 
1. Bash 쉘 빌트인 명령성
1. 파이프, 리다이렉션
2. env, set, sudo, s, ecoirt, ps

2. 쉘스크립트 작성
문자열
-->
